# [Introduction to Reactive Programming](https://projectreactor.io/docs/core/release/reference/#intro-reactive)

Reactor 는 Reactive Programming 패러다임의 구현으로 다음과 같이 요약할 수 있다.

> Reactive programming 은 데이터가 흐르는 것과 과 변화가 전파되는 것과 같은 비동기 프로그래밍 패러다임이다. 
> 즉, 프로그래밍 언어를 통해정적 혹은 동적 데이터 스트림을 쉽게 다룰 수 있다.

 
Reactive programming 의 첫걸음으로 Microsoft 는 .NET 시스템 안에 Reactive Extensions(RX) 라이브러리를 만들었다.
그때 RxJava 가 JVM 에서 reactive programming 을 구현핸다. 

시간이 흐르고 JVM 에서 reactive 라이브러리를 위한 인터페이스 세트와 상호작용 규칙이 정의된 명세 자바 표준이 reactive stream 의 노력으로 알려지게 되었다.
이 인터페이스들은 Java9 의 Flow.class 속으로 통합되었다.

reactive programming 패러다임은 때로 object-oriented 언어 안에서 Observer design pattern 의 확장으로 나타난다.
또한 모든 라이브러리에 Iterable-Iterator 쌍과 같은 이중성이 존재하므로 reactive streams 패턴을 친숙한 Iterator design pattern 과 비교할 수 있다.
큰 차이점 하나는 Iterator 는 pull 기반이라면 reactive streams 는 push 기반이다. 

값에 대한 접근 메서드가 **Iterable** 의 책임임에도 불구하고 **Iterator** 를 사용하는 것은 명령형 프로그래밍 패턴입니다. 실제로 Sequence 에서 next() 메서드의 접근 시기를 결정하는 것은 개발자의 책임입니다. Reactive stream 에서 위의 예시와 쌍을 이루는 것은 Publisher-Subscriber 입니다. 그러나 **Subscriber** 에게 제공받은 새로운 이용가능한 값을 알려주는 것은 **Publisher** 이며 이러한 Push 관점은 Reactive 를 이루는 중요한 열쇠입니다

값을 push 하는 것 외에도 에러 처리나 완료 관점 또한 잘 정의하여 다루어야 합니다. Publisher 는 새로운 값을 Subscript 에게 onNext 메서드를 호출하여 push 할 수 있고 에러(onError 호출) 혹은 완료(onComplete 호출) 메시지를 보낼 수 있습니다. 에러와 완료는 sequence 를 종료시킵니다. 이것은 다음과 같이 요약할 수 있습니다.

```css
onNext x.0..N [onError | onComplete]
```

이 접근은 매우 유연합니다.이 패턴은 값이 없을 때, 하나일 때, 여러개일 때(시계가 연속적으로 흘러가는 것처럼 값의 무한한 연속을 포함하여) 의 이용을 지원합니다.

그러나 왜 우리는 첫번째 장에서 비동기적인 reactive 라이브러리를 필요로 해야 하는 걸까요?
