# [Introduction to Reactive Programming](https://projectreactor.io/docs/core/release/reference/#intro-reactive)

Reactor 는 Reactive Programming 패러다임의 구현으로 다음과 같이 요약할 수 있다.

> Reactive programming 은 데이터가 흐르는 것과 과 변화가 전파되는 것과 같은 비동기 프로그래밍 패러다임이다. 
> 즉, 프로그래밍 언어를 통해정적 혹은 동적 데이터 스트림을 쉽게 다룰 수 있다.

 
Reactive programming 의 첫걸음으로 Microsoft 는 .NET 시스템 안에 Reactive Extensions(RX) 라이브러리를 만들었다.
그때 RxJava 가 JVM 에서 reactive programming 을 구현핸다. 

시간이 흐르고 JVM 에서 reactive 라이브러리를 위한 인터페이스 세트와 상호작용 규칙이 정의된 명세 자바 표준이 reactive stream 의 노력으로 알려지게 되었다.
이 인터페이스들은 Java9 의 Flow.class 속으로 통합되었다.

reactive programming 패러다임은 때로 object-oriented 언어 안에서 Observer design pattern 의 확장으로 나타난다.
또한 모든 라이브러리에 Iterable-Iterator 쌍과 같은 이중성이 존재하므로 reactive streams 패턴을 친숙한 Iterator design pattern 과 비교할 수 있다.
큰 차이점 하나는 Iterator 는 pull 기반이라면 reactive streams 는 push 기반이다. 

값에 대한 접근 메서드가 **Iterable** 의 책임임에도 불구하고 **Iterator** 를 사용하는 것은 명령형 프로그래밍 패턴입니다. 실제로 Sequence 에서 next() 메서드의 접근 시기를 결정하는 것은 개발자의 책임입니다. Reactive stream 에서 위의 예시와 쌍을 이루는 것은 Publisher-Subscriber 입니다. 그러나 **Subscriber** 에게 제공받은 새로운 이용가능한 값을 알려주는 것은 **Publisher** 이며 이러한 Push 관점은 Reactive 를 이루는 중요한 열쇠입니다

값을 push 하는 것 외에도 에러 처리나 완료 관점 또한 잘 정의하여 다루어야 합니다. Publisher 는 새로운 값을 Subscript 에게 onNext 메서드를 호출하여 push 할 수 있고 에러(onError 호출) 혹은 완료(onComplete 호출) 메시지를 보낼 수 있습니다. 에러와 완료는 sequence 를 종료시킵니다. 이것은 다음과 같이 요약할 수 있습니다.

```css
onNext x.0..N [onError | onComplete]
```

이 접근은 매우 유연합니다.이 패턴은 값이 없을 때, 하나일 때, 여러개일 때(시계가 연속적으로 흘러가는 것처럼 값의 무한한 연속을 포함하여) 의 이용을 지원합니다.

그런데 왜 우리는 첫번째로 비동기적인 reactive 라이브러리를 필요로 해야 하는 걸까요?

## Blocking Can Be Wasteful (Blocking 은 낭비일 수 있다)

요즘 애플리케이션은 수많은 동시 사용자이 접속할 수 있기 때문에 최신 하드웨어들의 성능이 지속적으로 증가하더라도 현대의 소프트웨어의 성능은 여전히 주요 관심사 입니다.

프로그램의 성능을 향상시킬 수 있는 방법은 크게 두 가지가 있습니다
- 더많은 쓰레드와 하드웨어 자원을 이용해 병렬처리하는 것
- 자원의 사용 방식에 대한 효율성을 높이는 것

일반적으로 자바 개발자는 blocking code 를 이용해 프로그램을 만듭니다. 이 방법은 성능의 bottleneck 에 이를 때까지 잘 동작합니다.
그때가 추가적인 blocking code 로 유사하게 동작하는 쓰레드를도입할 시간입니다.
