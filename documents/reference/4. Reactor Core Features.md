# 4. [Reactor Core Features](https://projectreactor.io/docs/core/release/reference/#core-features)

Reactor 프로젝트의 메인구조는 Reactive Stream 명세에 초점을 맞추고 Java 8 에 타겟팅 된 Reactive 라이브러리인 **react-core** 입니다.

Reactor 는 구성가능한 Publisher 를 구현하며 **Flux** 와 **Mono** 와 같은 여러 연산자들을 제공하는 reactive 타입을 소개했습니다.

**Flux** 객체는 0 ~ N 개의 아이템의 reactive sequence 를 말합니다. 반면에 **Mono** 객체는 한개 혹은 존재하지 않는 객체를 나타냅니다. 

이 구별은 약간의 의미 정보를 어떤 유형으로 전달하여 대략적인 비동기 처리의 cardinality 를 가리킵니다. 
예를 들어 HTTP 요청은 하나의 응답만을 만들어 내기 때문에 **count** 작업은 의미가 없습니다.
**Mono\<HttpResponse>** 로 어떤 HTTP 요청의 결과를 표현하는 것은 단지 없거나 하나만 있는 문맥과 연관된 연산을 제공하기 때문에
**Flux\<HttpResponse>** 로 표현하는 것 보다 의미있습니다. 

최대 집합(cardinality) 변경을 처리하는 연산자도 유사한 유형으로 전환됩니다. 
예를 들어 **count** 연산자는 **Flux** 에 있지만 **Mono\<Long>** 으로 반환됩니다.

## [4.1. Flux, an Asynchronous Sequence of 0-N Items](https://projectreactor.io/docs/core/release/reference/#flux) 

다음 예제는 **Flux** 가 어떻게 아이템들을 변환시키는 지를 보여줍니다.

![flux transform itmes](https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png)

**Flux\<T>** 는 선택적으로 완료 신호나 에러에 의해 종료된 0 에서 N 까지 방출된 아이템들의 비동기적인 순서를 나타내는 표준 **Publisher\<T>** 입니다.
Reactive Streams 명세에서 신호의 세가지 유형은 요청을 따라오는 Subscriber 의 **onNext**, **onComplete**, **onError** 메서드로 변환한다.

넓은 범위의 가능한 신호들에서 **Flux** 는 reactive 유형의 범용적인 목적의 유형입니다. 모든 이벤트들은 (심지어 끝나기도 한) 선택적으로 처리됩니다.
**onNext** 이벤트는 없이 **onComplete** 이벤트는 비어있는 유한의 순서들을 나타내지만 **onComplete** 메서드를 없애면 
무한한 빈 sequence 를 가질 수 있습니다.(취소에 대한 테스트를 제외하고 부분적으로 유용하지 않습니다)
유사하게 무한한 sequences 비어 있을 필요는 없습니다. 예를들어 **Flux.interval(Duration)** 은 무한한 **Flux\<Long>** 을 만들어 내고 
시계로부터 정기적인 신호를 내보냅니다.

## [4.2. Mono, an Asynchronous 0-1 Result](https://projectreactor.io/docs/core/release/reference/#mono)

다음의 이미지에서 어떻게 **Mono** 가 아이템을 변환하는지 보여줍니다.

![mono transform items](https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/mono.png)

**Mono<T>** 는 최대 하나의 아이템을 내보낸 다음 (선택적으로) `onComplete' 혹은 `onError` 신호와 함께 종료되는 특별한 Publisher<T> 이다.
  
 **Flux** 에서 사용할 수 있는 연산자 중 일부를 제공해주고, 일부 연산자는 (특히 `Mono`를 다른 `Publisher` 와 결합한) **Flux** 로 전환된다.
 예를들어 **Mono#concatWith(Publisher)** 는 **Flux** 를 반환하는 반면에 **Mono#then(Mono)** 는 또 다른 **Mono** 를 반환한다.
 
완료에 대한 개념만 있는 값이 없는 비동기 처리의 **Mono** 를 사용할 수 있다.(**Runnable** 과 유사하게)
하나만 만드려면 비어있는 **Mono\<Void>** 를 사용할 수 있다.

## [4.3.Simple Ways to Create a Flux or Mono and Subscribe to It](https://projectreactor.io/docs/core/release/reference/#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it)
**Flux** 와 **Mono** 를 시작하는 가장 쉬운 방법은 각가의 클래스에 있는 많은 팩토리 메서드들 중 하나를 사용하는 것이다.

예를 들어 다음에 나오는 것처럼 **String** 의 sequence 를 만들기 위해, 값들을 열거하고 collection 에 넣은 후 그로부터 Flux 를 만들 수 있다. 

```java
Flux<String> seq1 = Flux.just("foo", "bar", "foobar");

List<String> iterable = Arrays.asList("foo", "bar", "foobar");
Flux<String> seq2 = Flux.fromIterable(iterable);
```
팩토리 메서드의 다른 예제를 살펴보자

```java
Mono<String> noData = Mono.empty(); // 1.
Mono<String> data = Mono.just("foo");
 
Flux<Integer> numbersFromFiveToSeven = Flux.range(5,3); // 2.
```
1. 팩터리 메서드는 값이 없어도 제네릭 타입을 따릅니다.
2. 첫번째 파라미터는 범위의 시작이고 두번째 파라미터는 만들어 내는 아이템의 개수입니다.

구독할때는 **Flux** 와 **Mono** 에 Java 8 람다를 사용해야 합니다. 
다음의 메서드 정의 예제처럼 다양한 다른 콜백 조합의 람다를 사용하는 변형된 `subscribe()` 메서드를 선택할 수 있습니다.

```java
subscribe(); // 1.

subscribe(Consumer<? super T> consumer); // 2.

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); // 3.
          
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); // 4.
          
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,
          Consumer<? super Subscription> subscriptionConsumer); // 5.
```

1. 구독하고 sequence 를 실행시킨다.
2. 각각의 생상된 값들과 함께 작업을 한다.
3. 값을 다룰 뿐만 아니라 에러 처리도 한다.
4. 값과 에러를 다루고 sequence 가 성공적으로 완료되었을 때 특정 코드를 동작시킨다.
5. 값과 에러, 성공적인 완료를 다루고 **subscribe** 호출에 의해 만들어진 **Subscription** 와 함께 작업을 한다.








