# 4. [Reactor Core Features](https://projectreactor.io/docs/core/release/reference/#core-features)

Reactor 프로젝트의 메인구조는 Reactive Stream 명세에 초점을 맞추고 Java 8 에 타겟팅 된 Reactive 라이브러리인 **react-core** 입니다.

Reactor 는 구성가능한 Publisher 를 구현하며 **Flux** 와 **Mono** 와 같은 여러 연산자들을 제공하는 reactive 타입을 소개했습니다.

**Flux** 객체는 0 ~ N 개의 아이템의 reactive sequence 를 말합니다. 반면에 **Mono** 객체는 한개 혹은 존재하지 않는 객체를 나타냅니다. 

이 구별은 약간의 의미 정보를 어떤 유형으로 전달하여 대략적인 비동기 처리의 cardinality 를 가리킵니다. 
예를 들어 HTTP 요청은 하나의 응답만을 만들어 내기 때문에 **count** 작업은 의미가 없습니다.
**Mono\<HttpResponse>** 로 어떤 HTTP 요청의 결과를 표현하는 것은 단지 없거나 하나만 있는 문맥과 연관된 연산을 제공하기 때문에
**Flux\<HttpResponse>** 로 표현하는 것 보다 의미있습니다. 

최대 집합(cardinality) 변경을 처리하는 연산자도 유사한 유형으로 전환됩니다. 
예를 들어 **count** 연산자는 **Flux** 에 있지만 **Mono\<Long>** 으로 반환됩니다.

## [4.1. Flux, an Asynchronous Sequence of 0-N Items](https://projectreactor.io/docs/core/release/reference/#flux) 

다음 예제는 **Flux** 가 어떻게 아이템들을 변환시키는 지를 보여줍니다.

![flux transform itmes](https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/flux.png)

**Flux\<T>** 는 선택적으로 완료 신호나 에러에 의해 종료된 0 에서 N 까지 방출된 아이템들의 비동기적인 순서를 나타내는 표준 **Publisher\<T>** 입니다.
Reactive Streams 명세에서 신호의 세가지 유형은 요청을 따라오는 Subscriber 의 **onNext**, **onComplete**, **onError** 메서드로 변환한다.

넓은 범위의 가능한 신호들에서 **Flux** 는 reactive 유형의 범용적인 목적의 유형입니다. 모든 이벤트들은 (심지어 끝나기도 한) 선택적으로 처리됩니다.
**onNext** 이벤트는 없이 **onComplete** 이벤트는 비어있는 유한의 순서들을 나타내지만 **onComplete** 메서드를 없애면 
무한한 빈 sequence 를 가질 수 있습니다.(취소에 대한 테스트를 제외하고 부분적으로 유용하지 않습니다)
유사하게 무한한 sequences 비어 있을 필요는 없습니다. 예를들어 **Flux.interval(Duration)** 은 무한한 **Flux\<Long>** 을 만들어 내고 
시계로부터 정기적인 신호를 내보냅니다.

## [4.2. Mono, an Asynchronous 0-1 Result](https://projectreactor.io/docs/core/release/reference/#mono)

다음의 이미지에서 어떻게 **Mono** 가 아이템을 변환하는지 보여줍니다.

![mono transform items](https://raw.githubusercontent.com/reactor/reactor-core/v3.0.7.RELEASE/src/docs/marble/mono.png)

**Mono<T>** 는 최대 하나의 아이템을 내보낸 다음 (선택적으로) `onComplete' 혹은 `onError` 신호와 함께 종료되는 특별한 Publisher<T> 이다.
  
 **Flux** 에서 사용할 수 있는 연산자 중 일부를 제공해주고, 일부 연산자는 (특히 `Mono`를 다른 `Publisher` 와 결합한) **Flux** 로 전환된다.
 예를들어 **Mono#concatWith(Publisher)** 는 **Flux** 를 반환하는 반면에 **Mono#then(Mono)** 는 또 다른 **Mono** 를 반환한다.
 
완료에 대한 개념만 있는 값이 없는 비동기 처리의 **Mono** 를 사용할 수 있다.(**Runnable** 과 유사하게)
하나만 만드려면 비어있는 **Mono\<Void>** 를 사용할 수 있다.

## [4.3.Simple Ways to Create a Flux or Mono and Subscribe to It](https://projectreactor.io/docs/core/release/reference/#_simple_ways_to_create_a_flux_or_mono_and_subscribe_to_it)
**Flux** 와 **Mono** 를 시작하는 가장 쉬운 방법은 각가의 클래스에 있는 많은 팩토리 메서드들 중 하나를 사용하는 것이다.

예를 들어 다음에 나오는 것처럼 **String** 의 sequence 를 만들기 위해, 값들을 열거하고 collection 에 넣은 후 그로부터 Flux 를 만들 수 있다. 

```java
Flux<String> seq1 = Flux.just("foo", "bar", "foobar");

List<String> iterable = Arrays.asList("foo", "bar", "foobar");
Flux<String> seq2 = Flux.fromIterable(iterable);
```
팩토리 메서드의 다른 예제를 살펴보자

```java
Mono<String> noData = Mono.empty(); // 1.
Mono<String> data = Mono.just("foo");
 
Flux<Integer> numbersFromFiveToSeven = Flux.range(5,3); // 2.
```
1. 팩터리 메서드는 값이 없어도 제네릭 타입을 따릅니다.
2. 첫번째 파라미터는 범위의 시작이고 두번째 파라미터는 만들어 내는 아이템의 개수입니다.

구독할때는 **Flux** 와 **Mono** 에 Java 8 람다를 사용해야 합니다. 
다음의 메서드 정의 예제처럼 다양한 다른 콜백 조합의 람다를 사용하는 변형된 `subscribe()` 메서드를 선택할 수 있습니다.

```java
subscribe(); // 1.

subscribe(Consumer<? super T> consumer); // 2.

subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer); // 3.
          
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer); // 4.
          
subscribe(Consumer<? super T> consumer,
          Consumer<? super Throwable> errorConsumer,
          Runnable completeConsumer,
          Consumer<? super Subscription> subscriptionConsumer); // 5.
```

1. 구독하고 sequence 를 실행시킨다.
2. 각각의 생상된 값들과 함께 작업을 한다.
3. 값을 다룰 뿐만 아니라 에러 처리도 한다.
4. 값과 에러를 다루고 sequence 가 성공적으로 완료되었을 때 특정 코드를 동작시킨다.
5. 값과 에러, 성공적인 완료를 다루고 **subscribe** 호출에 의해 만들어진 **Subscription** 와 함께 작업을 한다.

> :memo: 이러한 변형은 더 이상 데이터가 필요하지 않을 때 구독을 취소하는데 필요한 구독에 대한 참조를 반환합니다.
> 취소하면 source 는 값을 생성하는 것을 멈추고 생성된 모든 자원을 정리해야 합니다.
> 이런 취소 및정리 작업은 Reactor 에서 범용적인 목적의 `Disposable` interface 로 표시됩니다.

### [4.3.1. subscribe Method Examples](https://projectreactor.io/docs/core/release/reference/#_subscribe_method_examples)

이번 장에는 **subscribe** 메서드에 대한 다섯개의 작은 핵심 예제를 포함합니다.
다음의 코드는 인자가 없는 기본 메서드의 예제를 보여줍니다.

```java
Flux<Integer> ints = Flux.range(1,3); // 1.
ints.subscribe(); // 2.
```

1. subscribe 가 실행될 때 세개의 값을 만드는 **Flux** 를 설정한다.
2. 가장 간단한 방법으로 구독한다.

이 코드는 보이지 않는 결과를 만들지만 잘 동작한다. **Flux** 는 세 개의 값을 만든다.
만약 람다를 제공한다면 눈에 보이는 값을 만들 수 있다. 다음의 **subscribe** 메서드 예제는 보이는 값을 만드는 예제를 보여준다.

```java
Flux<Integer> ints = Flux.ranges(1,3); // 1.
ints.subscribe(i -> System.out.println(i)); // 2.
```

1. subscribe 가 실행될 때 세개의 값을 만드는 **Flux** 를 설정한다.
2. 값을 프린트하는 subscriber 를 구독한다.

이전의 코드는  다음의 값을 만든다.

```text
1
2
3
```

다음의 핵심적인 부분을 설명하기 위해 다음의 예제에서 내부적으로 에러를 만들어 낸다.

```java
Flux<Integer> ints = Flux.range(1,4) // 1.
    .map(i -> { // 2.
      if (i <= 3) return i; // 3.
      throw enw RuntimeException("Got to 4"); // 4.
    });

ints.subscribe(i -> System.out.println(i), // 5.
  error -> System.err.println("Error: " + error));
```

1. subscribe 가 실행될 때 네개의 값을 만드는 **Flux** 를 설정한다.
2. 몇몇 값을 다르게 다루기 위해 map 함수를 사용해야 한다.
3. 대부분의 값들은 값을 반환한다.
4. 그중 한 값은 에러를 발생시킨다.
5. 에러 처리기를 포함한 subscriber 를 구독한다.

두개의 람다 표현식이 있는데 첫번째는 기대하는 것과 에러 처리를 위한 것이다.
이전의 코드에서 다음의 결과값을 만들었다.

```text
1
2
3
Error: java.lang.RuntimeException: Got to 4
```

다음의 예제는 **subscribe** 핵심 메서드는 에러  처리와 완료 이벤트 처리를 모두 포함한다.

```java
Flux<Integer> ints = Flux.range(1,4); // 1.
ints.subscribe(i -> System.out.println(i),
    error -> System.err.println("Error: " + error),
    () -> System.out.println("Done")); // 2.
```

1. subscribe 가 실행될 때 네개의 값을 만드는 **Flux** 를 설정한다.
2. 완료 이벤트 처리기를 포함한 Subscriber 를 구독한다.

에러와 완료신호 둘 모두 종료 이벤트이며 서로 배타적입니다. (둘 모두 얻을 수 없다)
완료 consumer 가 실행되려면 에러를 발생시켜서는 안됩니다.

완료 콜백은 괄호의 비어있는 쌍으로 나타내어 입력값이 없습니다. 마치 **Runnable** 인터페이스의 **run** 메서드와 일치합니다.
이전의 코드는 다음의 결과값을 만들어 냅니다.

```text
1
2
3
4
Done
```

마지막 **subscribe** 메서드의 핵심은 **Consumer\<Subscription>** 을 포함하는 것입니다.

> :info: 이 변형은 `Subscription` 으로 무언가를 하도록 요청합니다.(request(long) 요청하거나 cancle() 취소하거나) 그렇지 않으면 `Flux` 가 중단됩니다.

다음의 예제는 마지막 **subscribe** 메서드의 핵심을 보여줍니다.

```java
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(i -> System.out.println(i),
    error -> System.err.println("Error : " + error),
    () -> System.out.println("Done"),
    sub -> sub.request(10)); // 1.
```

1. `Subscription` 을 받는 구독을 할때 source 로 부터 `10`개의 요소를 받는 신호를 보냅니다.(실제로 4개의 요소를 전달하고 종료될 것입니다.)

### [4.3.2. Cancelling a subscribe() with Its Disposable](https://projectreactor.io/docs/core/release/reference/#_cancelling_a_subscribe_with_its_disposable)

모든 람다 기반의 **subscribe()** 의 변형은 **Disposable** 반환 타입을 가집니다. 이런 경우 **Disposable** 인터페이스는 
subscription 이 **dispose()** 메서드의 호출로 취소될 수 있습니다.

**Flux** 와 **Mono** 에서 취소는 source 가 요소의 생산을 멈춰야 한다는 신호입니다.
그러나 즉시 멈추는 것은 보장되지 않습니다. 몇몇 source 는 elements 를 매우 빠르게 만들어내어 심지어 취소 요청을 받기 전에 완료 될 수 있다.

몇몇 **Disposable** 유틸리티는 **Disposable** 클래스안에서 사용할 수 있다. 이 중에, **Disposables.swap()** 메서드는 **Disposable** 의 
자동으로 **Disposable** 구현체를 취소하거나 교체할 수 있는 포장객체를 만든다.

사용자가 버튼을 클릭 할 때마다 요청이 취소되거나 새로운 것으로 교체되기를 원하는 UI 시나리오에서 이 객체는 매우 유용하다.
포장 객체 자체를 폐기하면 해당 객체는 닫힙니다. 그렇게하면 현제 구현값들과 미래에 바뀌는 모든 것들이 폐기됩니다.

또 다른 흥미로운 유틸리티는 **Disposables.composite(...)** 입니다. 
이 composite 을 사용하면 여러 `Disposable`(서비스 요청과 같은 여러개의 내부적인 요청) 을 수집하고 나중에 한번에 모두 처리할 수 있습니다.
composite 의 **dispose()** 메서드가 호출되면 또 다른 **Disposable** 을 추가하기 위한 시도는 즉시 처리됩니다.

### [4.3.3. An Alternative to Lambdas: BaseSubscriber](https://projectreactor.io/docs/core/release/reference/#_an_alternative_to_lambdas_basesubscriber)

보다 일반적인 추가된 **subscriber** 메서드가 있으며 람다를 구성하는 대신 모든 특성을 갖춘 **Subscriber** 사용합니다.
**Subscriber** 를 만드는데 도움을 주기 위해, **BaseSubscriber** 라고 불리는 확장가능한 클래스를 제공합니다.

> :info: **BaseSubscriber** (혹은 하위 클래스) 객체는 `일회용` 입니다. 
> 즉 만약 두번째 **Publisher** 로부터 구독된다면 첫번재 **Publisher** 에 대한 구독은 취소됩니다.
> 객체를 두번 사용하는 것이 **Subscriber** 의 **onNext** 메서드를 병렬로 호출하면 안되는 `Reactive Streams` 의 규칙을 위반하는 이유입니다.
> 그 결과로 익명 구현체는 `Publisher#subscribe(Subscriber)` 의 호출에서 직접적으로 선언되어 지는 경우에만 적합 합니다

이들 중 하나를 구현할 수 있으며 `SampleSubscriber` 라고 부릅니다. 다음의 예제에서 어떻게 **Flux** 가 접목되는지 보여줍니다.

```java
SampleSubscriber<Integer> ss = new SampleSubscriber<Integer>();
Flux<Integer> ints = Flux.range(1, 4);
ints.subscribe(i -> System.out.println(i),
  error ->  System.err.println("Error: " + error),
  ()  ->  {System.out.println("Done");},
  s -> s.request(10));
ints.subscribe(ss);
```

다음의 예제는 **BaseSubscriber** 의 최소 구현으로 **SampleSubscriber** 의 모습을 보여줍니다.

```java
package io.projectreactor.samples;

import org.reactivestreams.Subscription;
import reactor.core.publisher.BaseSubscriber;

public class SampleSubscriber<T> extends BaseSubscriber<T> {
  public void hookOnSubscriber(Subscription subscription) {
    System.out.println("Subscribed");
    request(1);
  }
  public void hookOnNext(T value) {
    System.out.println(value);
    request(1);
  }
}
```

Reactor 에서 사용자가 정의로 추천하는 **Subscribers** 추상 클래스로 **SampleSubscriber** 클래스는 **BaseSubscriber** 를 상속한다.
subscriber 의 행동을 설정하기 위해 재정의할 수 있는 훅 메서드를 제공한다.
기본적으로 제한없는 요청을 발생시키고 `subscribe()` 처럼 동작합니다.
하지만 커스텀한 요청의 양을 원할 때 **BaseSubscriber** 를 확장하는 것은 더욱 도움이 됩니다.

커스텀한 요청을 위해, 최소한 해야하는 것은 위에서 했던것 처럼 `hookOnSubscribe(Subscription subscription)` 과 `hookOnNext(T value)` 입니다.
이 경우 `hookOnSubscribe` 메서드는 명령문을 표준출력으로 인쇄하고 첫번째 요청을 만듭니다.
그 다음 **hookOnNext**  메서드가 명령문을 인쇄하고 추가적인 요청을 요청당 한번씩 수행합니다.

**SampleSubscriber** 클래스는 다음의 결과값을 출력합니다.

```text
Subscribed
1
2
3
4
```

**BaseSubscriber** 는 **cancel()** 메서드 뿐만 아니라 또한 제한없는 모드(request(Long.MAX_VALUE 와 동일한))를 바꾸기 위해 **requestUnbounded()** 메서드를 제공합니다.

또한 다음의 추가적인 hooks 을 가집니다: **hookOnComplete**, **hookOnError**, **hookOnCancel**, **hookFinally**
(**SignalType** 파라미터처럼 전달된 종료타입과 함께 언제나 sequence 가 종료되었을때만 호출됩니다.)

> :information_source: 거의 확실히 **hookOnError**, **hookOnCancel**, **hookOnComplete** 메서드를 구현하기 원할 것 입니다.
> 또한 **hookFinally** 메서드를 구현하기 원할 수 도 있습니다. 
> **SampleSubscribe** 는 절대적으로 최소한의 제한된 요청을 수행하는 **Subscriber** 구현체입니다.

### [4.3.4.On Backpressure and Ways Reshape Requests](https://projectreactor.io/docs/core/release/reference/#_on_backpressure_and_ways_to_reshape_requests)

리액터에서 배압을 구현할 때 consumer 의 배압 요청이 source 로 거꾸로 전파 하기 위해 upstream 연산자에 `request` 를 전송한다.
현재 요청의 합계는 때때로 현재의 "요구" 또는 "보류중인 요청" 이라고 합니다.
요청의 한계는 `Long.MAX_VALUE` 이며 요청에 제한이 없다고 생각하면 됩니다.(기본적으로 배압이 비활성화 되어있고 가능한 빠르게 생산한다고 의미합니다.)

첫번째 요청은 구독 시간에 최종 구독자로부터 왔지만 구독하는 가장 직접적인 방법은 **Long.MAX_VALUE** 의 제한없는 요청을 모두 즉시 동작시키는 것이다:
- `subscribe()` 와 대부분 람다 기반의 변형() (Consumer\<Subscription> 을 제외하고)
- `block()`, `blockFirst()` 와 `blockLast()`
- `toIterable` 또는 `toStream`을 반복

본래의 요청을 커스터마이징하는 가장 간편한 방법은 `hookOnSubscribe` 메서드르 재정의한 `BaseSubscriber`를 이용해 `subscriber` 를 호출하는 것이다.
다음의 예를 보자

```java
Flux.range(1, 10)
  .doOnRequest(r -> System.out.println("request of " + r))
  .subscribe(new BaseSubscriber<Integer>() {
    @Override
    public void hookOnSubscriber(Subscription subscription) {
      request(1);
    }
    @Override
    public void hookOnNext(Integer integer) {
      System.out.println("Cancelling after having received " + integer);
      cancel();
    }
  });
```

앞의 예제는 다음을 출력합니다.
```text
request of 1
Cancelling after having received 1
```

> :exclamation: 요청을 다룰때 sequence 를 진행하기 위한 충분한 수요가 만들어지도록 주의해 합니다. 그렇지 않으면 Flux 가 "갇혀"버릴 수 있습니다.
> 이것이 `BaseSubscriber` 가 `hookOnRequest` 에서 제한받지 않는 요청을 기본을 하는 이유입니다.
> 이 hook 메서드를 재정의할 때, 적어도 한 버 이상의 요청을 호출해야 합니다.

#### Operators that Change the demand from Downstream

명심해야 하는 것은 구독 레벨에서 보이는 수요는 업 스트림 체인에서 각 연산자에 의해 재구성 될 수 있다.
일반적인 사례는 `buffer(n)` 연산자 입니다.
만약 `request(2)` 를 요청받으면 `두 개의 전체 버퍼`에 대한 요구로 해석됩니다.
결과적으로 버퍼는 가득찬 것으로 간주되어지는 `N` 개의 요소들을 필요로 하기 때문에 버퍼 연산자는 요청을 **2 X N** 으로 재구성 합니다.

